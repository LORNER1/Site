<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>History — My Site</title>
</head>
<body class="page-history">
    <header>
        <div class="container">
            <h1 style="margin:0; font-size:2.0rem;">My site — History</h1>
            <nav aria-label="Main navigation" style="margin-top:8px;">
                <a href="index.html">Index</a>
                <a href="trends.html">Trends</a>
            </nav>
        </div>
    </header>

    <main class="container">
        <section>
            <h2>HISTORY</h2>
            <h3>Historical Evolution of Version Control Systems</h3>
            <p>The evolution of VCS spans several decades, with distinct generations of tools marking key milestones.
Early systems were centralized, relying on a single repository server, while later systems introduced
distributed collaboration. Below is a timeline of major milestones in VCS history, from the 1970s to
today, illustrating this evolution</p>

            <ul>
                <li>1972: Source Code Control System (SCCS) – one of the first version control systems, developed
at Bell Labs, which introduced the basic idea of tracking changes (initially used on IBM
mainframes). 
</li>
            <li>1982: <b>Revision Control System (RCS)</b> – released by Walter Tichy at Purdue University, RCS
automated change tracking for individual files using delta storage (storing differences between
file versions) . RCS was a local VCS (no network support), handling one file at a time.</li>
            <li>1986: <b>Concurrent Versions System (CVS)</b> – developed by Dick Grune as a front-end to RCS, CVS
allowed collaboration on whole projects with a client-server model . It added networked
repositories and concurrent multi-developer capabilities to RCS.</li>
            <li>2000: <b>Subversion (SVN)</b> – created by CollabNet as a successor to CVS, Subversion improved on
CVS’s weaknesses. SVN introduced atomic commits (all-or-nothing changesets), better handling
of file renames, and more efficient network operations</li>
            <li>2005: <b>Git and Mercurial</b> – a breakthrough year for version control. In 2005, after the Linux
kernel’s commercial VCS (BitKeeper) license was revoked, Linus Torvalds created Git as a new
distributed VCS for the kernel</li>
            <ul>
                <li>Around the same time, Matt Mackall released Mercurial. Both
Git and Mercurial are distributed version control systems (DVCS)</li>
            </ul>
            </ul>

            <h3>Centralized vs. Distributed Version Control</h3>
            <b>Version control systems can be centralized or distributed. Understanding this distinction is key to
comparing tools and workflows:
</b>
            <ul>
            <li><b>Centralized Version Control (CVCS)</b>: A single central repository on a server holds the “official”
copy of the code. Developers commit changes to this server and update (pull) changes from it.
Tools like RCS, CVS, and Subversion are centralized. In a CVCS, collaboration requires network
access to the server – if the server is down, nobody can commit changes. This model provides a
single source of truth and is straightforward to understand: everyone works on the same central
codebase .</li>
            <li><b>Centralized VCS Example:</b>The figure below illustrates a simple centralized VCS setup, with developers
interacting with a single shared repository</li>
            <li><b>Distributed Version Control (DVCS):</b>In distributed systems like Git or Mercurial, every developer
has their own full copy of the repository, including the entire history . There is no inherent
single master server – every clone can serve as a remote for others. Developers can commit
changes locally to their own repository (even offline), and later push those changes to share with
others or pull updates from peers</li>
            <li><b>In summary:</b>Centralized systems are simple and good for a single source of truth, but suffer from
single-point failures and require connectivity for most operations.</li>
            </ul>

            <h3>Comparing Major VCS Tools and Their Use Cases</h3>
            <b>Over time, various VCS tools have been created, each suited to certain use cases and project sizes.
Here’s a comparison of some historically significant systems:</b>
            <ul>
                <li><b>RCS (Revision Control System):</b> Type: Local (centralized for single files). Use case: Individual
developers or small projects needing versioning on single files. RCS works on one file at a time
(no multi-file atomic commits).</li>
                <li><b>CVS (Concurrent Versions System):</b>Type: Centralized client-server. Use case: Small-to-medium
team projects (up to the 2000s) that need basic collaboration. CVS was popular in open source
(e.g. early Linux, GNOME, etc.) and introduced the idea of concurrent editing (multiple
developers working on the code simultaneously).</li>
                <li><b>Subversion (SVN):</b> Type: Centralized. Use case: Projects needing a more robust central VCS than
CVS. SVN improved reliability – commits are atomic (all files commit or none) and branching/
merging is better supported than in CVS.</li>
                <li><b>Git:</b>: Type: Distributed. Use case: Almost any scale – from individual projects to the largest opensource endeavors. Git is extremely fast at branching and merging, making it ideal for projects
where developers create many experimental branches or work in parallel.</li>
                <li><b>Mercurial:</b>Type: Distributed. Use case: Similar to Git in scope – Mercurial was designed for
performance and ease of use with a DVCS model.</li>
                <li><b>Other tools:</b>Perforce (Helix) is a fast centralized VCS often used in game development and large
binary asset repositories (it handles huge files well and has fine-grained locking capabilities –
useful for cases where merging binaries is impossible).</li>
            </ul>
        </section>
    </main>
</body>
</html>